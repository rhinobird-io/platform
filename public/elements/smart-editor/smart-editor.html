<link rel="import" href="../../bower_components/core-ajax/core-ajax.html">
<link rel="import" href="../../bower_components/core-selector/core-selector.html">
<link rel="import" href="../../bower_components/paper-input/paper-autogrow-textarea.html">
<link rel="import" href="../../bower_components/paper-input/paper-input-decorator.html">
<link rel="import" href="../../bower_components/paper-shadow/paper-shadow.html">
<link rel="import" href="../../bower_components/paper-dialog/paper-action-dialog.html">
<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/ajax-file-input/ajax-file-input.html">
<link rel="import" href="../member-select/member-element.html">
<link rel="import" href="../x-completion/x-completion.html">

<!--
    Attributes:

    label, floatingLabel, underline:
        Applied to paper-input-decorator.

    value, rows, maxRows:
        Applied to (paper-autogrow-)textarea.

    flushKey:
        Optional values: "none", "enter", "ctrl-enter".
-->

<polymer-element name="smart-editor" attributes="label value rows maxRows flushKey floatingLabel underline disabled">
    <template>
        <style>
            #selector {
                position: absolute;
                background-color: #C5CAE9;
                z-index: 10;
                cursor: pointer;
            }

            .core-selected {
                background-color: #FF4081;
                color: white;
            }

            .wrapper {
                position: relative;
            }

            paper-autogrow-textarea {
                width: 100%;
            }

            paper-input-decorator /deep/ .input-body {
                line-height: 1.2em;
            }

            .manual {
                color: rgba(0, 0, 0, 0.54);
                font-style: italic;
            }

            .core-selected .manual {
                color: rgba(255, 255, 255, 0.7);
                font-style: italic;
            }
        </style>

        <paper-input-decorator label="{{label}}" id="decorator">
            <paper-autogrow-textarea id="autogrow" rows="{{rows}}" maxRows="{{maxRows}}" disabled="{{disabled}}">
                <textarea on-input="{{textInputted}}" on-blur="{{inputBlur}}" id="textarea" disabled="{{disabled}}"
                          value="{{value}}"></textarea>
            </paper-autogrow-textarea>
        </paper-input-decorator>

        <div class="wrapper">
            <x-completion z="1" id="selector" controller="{{$.textarea}}" on-select="{{selectHandler}}"
                          controllerKeydownHandler="{{doFilter}}">
                <template if="{{completingChar == '@'}}">
                    <template repeat="{{ u in filteredUsers}}">
                        <div>
                            <member-element username="{{u.name}}"></member-element>
                        </div>
                    </template>
                </template>
                <template if="{{completingChar == '/'}}">
                    <template repeat="{{ c in filteredCommands}}">
                        <div>/{{c.name}}<span class="manual">{{c.manual}}</span></div>
                    </template>
                </template>
            </x-completion>
        </div>

        <paper-action-dialog backdrop autoCloseDisabled id="fileUpload" vertical layout>
            <ajax-file-input id="fileInput" url="/file/files" on-success="{{fileUploaded}}"></ajax-file-input>
            <paper-button affirmative autofocus on-tap="{{cancelFileUpload}}">Cancel</paper-button>
        </paper-action-dialog>
        <core-ajax url="/platform/users" auto handleAs="json" response="{{users}}"></core-ajax>
    </template>

    <script src="../../lib/textarea-caret-position.js"></script>
    <script>
        function getCaretCoordinates(textArea, textPos) {
            var getCaretPosition = require('textarea-caret-position');
            var caretPosition = getCaretPosition(textArea, textPos);
            var coord = {};
            coord.textTop = caretPosition.top;
            coord.textLeft = caretPosition.left;
            coord.top = coord.textTop - textArea.scrollTop;
            coord.left = coord.textLeft - textArea.scrollLeft;
            coord.bottom = textArea.offsetHeight - coord.top;
            coord.right = textArea.offsetWidth - coord.left;
            return coord;
        }

        Polymer({
            publish: {
                floatingLabel: false,
                underline: false
            },
            disabled: false,

            ready: function () {
                this.$.decorator.floatingLabel = this.floatingLabel;
                if (this.underline == false) {
                    this.$.decorator.$.underline.style.display = "none";
                }
            },
            commands: [{name: 'vity', manual: ':room_name'},
                {name: 'file', manual: ':file_id'}],
            textInputted: function (event, detail, target) {
                this.$.selector.active = false;
                var lastWord = target.value.substring(0, target.selectionEnd).match(/([^\s]*)$/)[1];
                if (lastWord.length == 0) {
                    return;
                }
                if (lastWord.charAt(0) == '@' || lastWord.charAt(0) == '/') {
                    this.completingChar = lastWord.charAt(0);
                    var menu = this.$.selector;
                    var coord = getCaretCoordinates(target, target.selectionEnd - lastWord.length);
                    menu.style.top = -coord.bottom + "px";
                    menu.style.left = coord.left + "px";
                    menu.style.right = "";
                    menu.style.marginTop = "1em";
                    var text = lastWord.substring(1);
                    if (this.completingChar == "@") {
                        this.filteredUsers = this.filterUser(text);
                        this.$.selector.active = this.filteredUsers.length ? true : false;
                    } else {
                        this.filteredCommands = this.filterCommand(text);
                        this.$.selector.active = this.filteredCommands.length ? true : false;
                    }

                    setTimeout(function () {
                        // Right-align the menu if needed.
                        if (menu.offsetWidth >= coord.right) {
                            menu.style.left = "";
                            menu.style.right = 0;
                        }
                        // Show menu above the text if needed.
                        if (menu.getBoundingClientRect().bottom >= window.innerHeight) {
                            var menuHeight = menu.offsetHeight;
                            if (target.getBoundingClientRect().top + coord.top > menuHeight) {
                                menu.style.top = -coord.bottom - menuHeight + "px";
                                menu.style.marginTop = "-1em";
                            }
                        }
                    }, 0);
                }
            },

            inputBlur: function () {
                //prevent missing mouse click event
                var self = this;
                setTimeout(function () {
                    self.$.selector.active = false;
                }, 100);
            },
            filterUser: function (text) {
                var result = [];
                text = text.toLowerCase();
                if (this.users) {
                    this.users.forEach(function (user) {
                        if ((user.email.toLowerCase().indexOf(text) != -1 || user.name.toLowerCase().indexOf(text) != -1 || user.realname.toLowerCase().indexOf(text) != -1) && result.length < 8) {
                            result.push(user);
                        }
                    }, this);
                }
                return result;
            },
            filterCommand: function (text) {
                var result = [];
                text = text.toLowerCase();
                this.commands.forEach(function (c) {
                    if (c.name.toLowerCase().indexOf(text) != -1) {
                        result.push(c);
                    }
                }, this);
                return result;
            },

            doFilter: function (event, detail, sender) {
                if ((this.flushKey == "enter" && !event.ctrlKey && !event.shiftKey && !event.altKey) ||
                        (this.flushKey == "ctrl-enter" && event.ctrlKey && !event.shiftKey && !event.altKey)) {
                    // Trigger flush function
                    event.preventDefault();
                    this.flush();
                } else {
                    this.$.selector.selected = 0;
                    this.$.selector.parentElement.scrollTop = 0;
                }
            },

            selectHandler: function (event, detail, target) {
                if (this.completingChar == "@") {
                    var user = detail.model.u;
                    this.replaceText("@" + user.name + " ");
                } else {
                    var c = detail.model.c;
                    this.replaceText("/" + c.name);
                    if (c.name == 'file') {
                        this.$.fileInput.clear();
                        this.$.fileUpload.open();
                    }
                }
                this.$.selector.active = false;
            },

            fileUploaded: function (event, detail, target) {
                var file = JSON.parse(detail.xhr.response);
                this.value += ":" + file.id + " ";
                this.$.fileUpload.close();
            },
            cancelFileUpload: function () {
                this.value = this.value.substring(0, this.value.length - 5);
            },
            replaceText: function (text) {
                var left, right;
                left = this.value.substring(0, this.$.textarea.selectionEnd);
                right = this.value.substring(this.$.textarea.selectionEnd);
                left = left.replace(/[^\s]*$/, text);
                this.value = left + right;
                var self = this;
                setTimeout(function () {
                    self.$.textarea.selectionEnd = left.length + 1;
                }, 0);
            },

            valueChanged: function () {
                var _this = this;
                setTimeout(function() {
                    _this.$.decorator.updateLabelVisibility(_this.value);
                    _this.$.autogrow.update(_this.$.textarea);
                }, 0);
            },

            clearText: function () {
                this.$.textarea.value = "";
            },

            flush: function () {
                this.fire("flush", {"value": this.$.textarea.value});
            }
        });

    </script>
</polymer-element>
